[
  {
    "objectID": "issue-332.html",
    "href": "issue-332.html",
    "title": "ipyautoui",
    "section": "",
    "text": "import typing as ty\nimport pandas as pd\nfrom pydantic import BaseModel, RootModel, Field\n\nimport ipyautoui.automapschema as asch\nfrom ipyautoui.custom.autogrid import AutoGrid, GridSchema\nfrom ipyautoui.custom.editgrid import EditGrid\nfrom ipyautoui.custom.iterable import AutoArrayForm\nfrom ipyautoui.autoobject import AutoObject\n\n\nclass Test(BaseModel):\n    text: str = \"\"\n    number: float\n\n\nclass TestDataFrame(RootModel):\n    root: ty.List[Test] = Field(format=\"dataframe\")\n\n\nmodel, schema = asch._init_model_schema(TestDataFrame)\ngridschema = GridSchema(schema)\ngridschema.coerce_data(pd.DataFrame([{\"number\": 2}]))\n\n\n\n\n\n\n\ntitle\nText\nNumber\n\n\n\n\n0\n\n2"
  },
  {
    "objectID": "issue-330.html",
    "href": "issue-330.html",
    "title": "ipyautoui",
    "section": "",
    "text": "# REF: https://github.com/maxfordham/ipyautoui/issues/330\n\n\n\n\n\nfrom pydantic import BaseModel\nfrom ipyautoui.autoobject import AutoObject\n\n\nclass Test(BaseModel):\n    text: str\n    number: float\n\n\nui = AutoObject.from_jsonschema(Test.model_json_schema(), value={\"text\": \"text\"})\ndisplay(ui)\n\n\n\n\n\nui.value = {\"number\": 4}"
  },
  {
    "objectID": "autovuetify.html",
    "href": "autovuetify.html",
    "title": "AutoVuetify",
    "section": "",
    "text": "Try on Binder\n\n\n\nThese docs requires a python kernel to run. Try on Binder\nAutoVjsf works in exactly the same way as AutoUi, but instead of using ipywidgets to render the JSON schema it uses ipyvuetify and vuetify-jsonschema-form.\nfrom IPython.display import IFrame\n\nIFrame(\n    width=\"600\",\n    height=\"500\",\n    sandbox=\"allow-same-origin allow-scripts allow-popups\",\n    frameborder=\"0\",\n    src=\"https://videos.koumoul.com/videos/embed/29d12ba2-f694-4659-8027-e9386692d8b5\",\n)"
  },
  {
    "objectID": "autovuetify.html#creating-simple-widget",
    "href": "autovuetify.html#creating-simple-widget",
    "title": "AutoVuetify",
    "section": "Creating Simple Widget",
    "text": "Creating Simple Widget\nSo let’s create a simple pydantic class. Here we have one text field.\n\nfrom ipyautoui import AutoVjsf\nimport json\nfrom pydantic import BaseModel, Field\nfrom ipyautoui.constants import DIR_MODULE\nfrom ipyautoui._utils import display_pydantic_json\n\n# create a pydantic model (or a json-schema) defining the fields of interest\nclass AutoUiExample(BaseModel):\n    text: str = Field(default=\"Test\", description=\"This description is very important\")\n\n\nimport pathlib\n\nvalue = {\"text\": \"this is a value\"}\nui = AutoVjsf(schema=AutoUiExample, value=value, path=pathlib.Path(\"test.json\"))\ndisplay(ui)  # uncomment\n\nboth a value and a path given. value will be used.\n\n\n\n\n\n\nA more Complex Example Model\nLet’s look at a complete pydantic model producing all of the possible widgets. within import ipyautoui.demo_schemas there is a class called CoreIpywidgets that outlines what is possible. Explore the python file below.\n\nfrom ipyautoui.demo_schemas import CoreIpywidgets\n\nui = AutoVjsf(CoreIpywidgets)\nui.show_raw = True\nui"
  },
  {
    "objectID": "issue-334.html",
    "href": "issue-334.html",
    "title": "ipyautoui",
    "section": "",
    "text": "import typing as ty\nimport pandas as pd\nfrom pydantic import BaseModel, RootModel, Field\nfrom ipyautoui.custom.autogrid import AutoGrid\nfrom ipyautoui.custom.editgrid import EditGrid, UiDelete\n\n\nautogrid = AutoGrid()\nautogrid\n\n\n\n\n\nclass DataFrameCols(BaseModel):\n    string: str = Field(\n        \"string\", json_schema_extra=dict(column_width=400, section=\"a\")\n    )\n\n\nclass TestDataFrame(RootModel):\n    \"\"\"a description of TestDataFrame\"\"\"\n\n    root: ty.List[DataFrameCols] = Field(\n        json_schema_extra=dict(\n            format=\"dataframe\", datagrid_index_name=(\"section\", \"title\")\n        ),\n    )\n\nautogrid.update_from_schema(TestDataFrame, data=pd.DataFrame([{\"string\": \"Test\"}]*10))\n\n\nclass TestDelete(UiDelete):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.message.value = (\n            \"⚠️&lt;b&gt;Are you sure you want to delete the following Types and Instances?&lt;/b&gt;⚠️&lt;br&gt;&lt;i&gt;Pressing the DELETE button will\"\n            \" permanently delete the selected Types and Instances!&lt;/i&gt;\"\n        )\nHEADER_BACKGROUND_COLOUR = \"rgb(207, 212, 252)\"\nGRID_STYLE = {\"header_background_color\": HEADER_BACKGROUND_COLOUR}\n\n\neditgrid = EditGrid(ui_delete=TestDelete, grid_style=GRID_STYLE)\ndisplay(editgrid)\n\n\n\n\n\nclass DataFrameCols(BaseModel):\n    string: str = Field(\n        \"string\", json_schema_extra=dict(column_width=400, section=\"a\")\n    )\n\n\nclass TestDataFrame(RootModel):\n    \"\"\"a description of TestDataFrame\"\"\"\n\n    root: ty.List[DataFrameCols] = Field(\n        json_schema_extra=dict(\n            format=\"dataframe\", datagrid_index_name=(\"section\", \"title\")\n        ),\n    )\neditgrid.update_from_schema(TestDataFrame, value=[{\"string\": \"Test\"}]*10, ui_delete=TestDelete)\n\n\nclass DataFrameCols(BaseModel):\n    integer: int = Field(\n        10, json_schema_extra=dict(column_width=400, section=\"a\")\n    )\n\n\n\nclass TestDataFrame(RootModel):\n    \"\"\"a description of TestDataFrame\"\"\"\n\n    root: ty.List[DataFrameCols] = Field(\n        json_schema_extra=dict(\n            format=\"dataframe\", datagrid_index_name=(\"section\", \"title\")\n        ),\n    )\neditgrid.update_from_schema(TestDataFrame)"
  },
  {
    "objectID": "autodisplay.html",
    "href": "autodisplay.html",
    "title": "AutoDisplay",
    "section": "",
    "text": "Try on Binder\n\n\n\nThese docs requires a python kernel to run. Try on Binder"
  },
  {
    "objectID": "autodisplay.html#render-a-list-of-files",
    "href": "autodisplay.html#render-a-list-of-files",
    "title": "AutoDisplay",
    "section": "Render a list of files",
    "text": "Render a list of files\n\nfrom ipyautoui.demo_schemas import CoreIpywidgets\nfrom ipyautoui import AutoUi, AutoDisplay\nfrom ipyautoui.autodisplay import DisplayPath\nfrom ipyautoui.constants import load_test_constants\nfrom IPython.display import display\nimport pathlib\n\ntests_constants = load_test_constants()\npaths = list(load_test_constants().DIR_FILETYPES.glob(\"*.*\"))\nad = AutoDisplay.from_paths(paths, display_showhide=False)\ndisplay(ad)"
  },
  {
    "objectID": "autodisplay.html#create-a-custom-renderer",
    "href": "autodisplay.html#create-a-custom-renderer",
    "title": "AutoDisplay",
    "section": "Create a custom renderer",
    "text": "Create a custom renderer\n\n# TODO: fix this\n\n# from ipyautoui.demo_schemas import CoreIpywidgets\n\n# user_file_renderers = AutoUi.create_autodisplay_map(\n#     ext=\".aui.json\", schema=CoreIpywidgets\n# )\n# tests_constants.PATH_TEST_AUI.write_text(\n#     CoreIpywidgets(int_text_req=3, int_text_nullable=None).model_dump_json(indent=4)\n# )\n\n# test_ui = AutoDisplay.from_paths(\n#     paths=[tests_constants.PATH_TEST_AUI],\n#     renderers=user_file_renderers,\n#     display_showhide=False,\n# )\n\n# display(test_ui)"
  },
  {
    "objectID": "custom-renderers.html",
    "href": "custom-renderers.html",
    "title": "Custom Renderers",
    "section": "",
    "text": "AutoUi is built using ipywidgets. It can be easily customised and extended… see ruleset in demo… More TBC"
  },
  {
    "objectID": "autoui.html",
    "href": "autoui.html",
    "title": "AutoUi",
    "section": "",
    "text": "Try on Binder\n\n\n\nThese docs requires a python kernel to run. Try on Binder\nWith ipyautoui we can create ipywidgets from either a json-schema or a pydantic model. This makes it quick and easy to whip up a user interface when required.\nfrom ipyautoui import AutoUi\nimport pathlib\nimport json\nfrom pydantic import BaseModel, Field, model_validator, ConfigDict\nfrom enum import Enum\nfrom ipyautoui.constants import DIR_MODULE\nfrom ipyautoui._utils import display_pydantic_json\nimport ipywidgets as w\nimport typing as ty\n# create a pydantic model (or a json-schema) defining the fields of interest\n\nclass Sub(BaseModel):\n    a: str = \"a\"\n    b: int = 1\n\nclass My(Enum):\n    \"asdfal;ksdfj\"\n    a = \"a\"\n    b = \"b\"\n\nclass Example(BaseModel):\n    text: str = Field(default=\"Test\", description=\"This description is very important\")\n    inty: int = 1\n    sub: Sub\n    nu: ty.Optional[str] = None\n    my: My\n\n\ndata = {\"text\": \"this is a value\"}\nui = AutoUi(\n    schema=Example,\n    path=pathlib.Path(\"test.ui.json\"),\n    show_savebuttonbar=True,\n)\ndisplay(ui)\nupdate the value of the form as you would any other ipywidget\nui.value = {'text': 'Test upates', 'inty': 1, 'sub': {'a': 'asdf', 'b': 3}, 'nu': \"not None\", 'my': 'b'}"
  },
  {
    "objectID": "autoui.html#updating-the-model-schema",
    "href": "autoui.html#updating-the-model-schema",
    "title": "AutoUi",
    "section": "Updating the model / schema",
    "text": "Updating the model / schema\nMinor changes to the model can be made. The keys and resulting widgets must remain the same, but the attributes that define them can change (i.e. descriptions, the options of Dropdown, limits of an integer etc.). You can also add validation logic in this way. This is to support the edge case where the parameters of a form must remain the same but the allowed values and other customisations can change.\n\nclass New(Enum):\n    \"asdfal;ksdfj\"\n    c = 1\n    d = 2\n    \nclass Example2(BaseModel):\n    \"\"\"some updated description\"\"\"\n    text: str = Field(default=\"Test\", description=\"This description is very important\")\n    inty: int = Field(default=4, description=\"This integer is very important\")\n    sub: Sub\n    nu: ty.Optional[str] = None\n    my: New\n\n    @model_validator(mode='after')\n    def v(self):\n        self.text = \"custom validation stuff...\"\n        return self\n\n    model_config = ConfigDict(json_schema_extra=dict(show_raw=True))\n\n\nui.update_model(Example2)\n\nWholesale updates of the model are not allowed.\n\n# this will fail as the model is completely different. \n# in this case you just want to new AutoUi object. \ntry:\n    ui.update_model(Sub)\nexcept Exception as e:\n    print(e)\n\nwidgets must match on schema change. changes intended for modifications of existing widgets only.\n\n\n\n# this will fail as the widgets that define the model need to change\n# as `inty` has changed from an `int` to a `str`\nclass Example1(BaseModel):\n    text: str = Field(default=\"Test\", description=\"This description is very important\")\n    inty: str = \"1\"\n    sub: Sub\n    nu: ty.Optional[str] = None\n    my: My\n\ntry:\n    ui.update_model(Example1)\nexcept Exception as e:\n    print(e)\n\nwidgets must match on schema change. changes intended for modifications of existing widgets only."
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Contributing",
    "section": "",
    "text": "ipyautoui uses pixi for package management and development. Once installed:"
  },
  {
    "objectID": "CONTRIBUTING.html#packaging",
    "href": "CONTRIBUTING.html#packaging",
    "title": "Contributing",
    "section": "Packaging",
    "text": "Packaging\n#  NOTE: restricted to core-maintainers only\npixi run build\nhatch publish -u __token__ -a &lt;your-pypi-token&gt;  # publishes to pypi"
  },
  {
    "objectID": "issue-336.html",
    "href": "issue-336.html",
    "title": "ipyautoui",
    "section": "",
    "text": "from pathlib import Path\nfrom ipyautoui.custom import FileChooser\n\n# Make a file so that we can set the value of FileChooser\np = Path(\"./dummy.txt\")\np.touch()\n\n# Make a FileChooser\nfc = FileChooser()\n\n# Define an observer that just prints the state of the FileChooser\ndef print_status(change):\n    print(f\"{change['new']=}\")\n    print(f\"{fc._value=}\")\n    print(f\"{fc.selected_path=}\")\n    print(f\"{fc.selected_filename=}\")\n\ndisplay(fc)\n# Observe the _value traitlet\nfc.observe(print_status, \"_value\")\n\n# set the value\nfc.value = str(p)\n\n\n\n\nchange['new']='dummy.txt'\nfc._value='dummy.txt'\nfc.selected_path='/home/jovyan/ipyautoui/docs'\nfc.selected_filename='dummy.txt'"
  },
  {
    "objectID": "reference/pydantic-jsonschema-mapping.html",
    "href": "reference/pydantic-jsonschema-mapping.html",
    "title": "ipyautoui",
    "section": "",
    "text": "# FOR REF\n\n# url = \"https://github.com/pydantic/pydantic-docs/blob/main/docs/build/schema_mapping.py\"\n\n#!/usr/bin/env python3\n\"\"\"\nBuild a table of Python / Pydantic to JSON Schema mappings.\n\nDone like this rather than as a raw rst table to make future edits easier.\n\nPlease edit this file directly not .tmp_schema_mappings.html\n\"\"\"\nfrom __future__ import annotations\nimport json\nimport re\nfrom pathlib import Path\nfrom typing import Any\n\ntable: list[tuple[str, str, str | dict[str, Any], str, str]] = [\n    (\n        'None',\n        'null',\n        '',\n        'JSON Schema Core',\n        'Same for `type(None)` or `Literal[None]`',\n    ),\n    (\n        'bool',\n        'boolean',\n        '',\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'str',\n        'string',\n        '',\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'float',\n        'number',\n        '',\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'int',\n        'integer',\n        '',\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'dict',\n        'object',\n        '',\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'list',\n        'array',\n        {'items': {}},\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'tuple',\n        'array',\n        {'items': {}},\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'set',\n        'array',\n        {'items': {}, 'uniqueItems': True},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'frozenset',\n        'array',\n        {'items': {}, 'uniqueItems': True},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'List[str]',\n        'array',\n        {'items': {'type': 'string'}},\n        'JSON Schema Validation',\n        'And equivalently for any other sub type, e.g. `List[int]`.',\n    ),\n    (\n        'Tuple[str, ...]',\n        'array',\n        {'items': {'type': 'string'}},\n        'JSON Schema Validation',\n        'And equivalently for any other sub type, e.g. `Tuple[int, ...]`.',\n    ),\n    (\n        'Tuple[str, int]',\n        'array',\n        {'items': [{'type': 'string'}, {'type': 'integer'}], 'minItems': 2, 'maxItems': 2},\n        'JSON Schema Validation',\n        (\n            'And equivalently for any other set of subtypes. Note: If using schemas for OpenAPI, '\n            \"you shouldn't use this declaration, as it would not be valid in OpenAPI (although it is \"\n            'valid in JSON Schema).'\n        ),\n    ),\n    (\n        'Dict[str, int]',\n        'object',\n        {'additionalProperties': {'type': 'integer'}},\n        'JSON Schema Validation',\n        (\n            'And equivalently for any other subfields for dicts. Have in mind that although you can use other types as '\n            'keys for dicts with Pydantic, only strings are valid keys for JSON, and so, only str is valid as '\n            'JSON Schema key types.'\n        ),\n    ),\n    (\n        'Union[str, int]',\n        'anyOf',\n        {'anyOf': [{'type': 'string'}, {'type': 'integer'}]},\n        'JSON Schema Validation',\n        'And equivalently for any other subfields for unions.',\n    ),\n    (\n        'Enum',\n        'enum',\n        '{\"enum\": [...]}',\n        'JSON Schema Validation',\n        'All the literal values in the enum are included in the definition.',\n    ),\n    (\n        'SecretStr',\n        'string',\n        {'writeOnly': True},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'SecretBytes',\n        'string',\n        {'writeOnly': True},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'EmailStr',\n        'string',\n        {'format': 'email'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'NameEmail',\n        'string',\n        {'format': 'name-email'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'AnyUrl',\n        'string',\n        {'format': 'uri'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'Pattern',\n        'string',\n        {'format': 'regex'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'bytes',\n        'string',\n        {'format': 'binary'},\n        'OpenAPI',\n        '',\n    ),\n    (\n        'Decimal',\n        'number',\n        '',\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'UUID1',\n        'string',\n        {'format': 'uuid1'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'UUID3',\n        'string',\n        {'format': 'uuid3'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'UUID4',\n        'string',\n        {'format': 'uuid4'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'UUID5',\n        'string',\n        {'format': 'uuid5'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'UUID',\n        'string',\n        {'format': 'uuid'},\n        'Pydantic standard \"format\" extension',\n        'Suggested in OpenAPI.',\n    ),\n    (\n        'FilePath',\n        'string',\n        {'format': 'file-path'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'DirectoryPath',\n        'string',\n        {'format': 'directory-path'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'Path',\n        'string',\n        {'format': 'path'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'datetime',\n        'string',\n        {'format': 'date-time'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'date',\n        'string',\n        {'format': 'date'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'time',\n        'string',\n        {'format': 'time'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'timedelta',\n        'number',\n        {'format': 'time-delta'},\n        'Difference in seconds (a `float`), with Pydantic standard \"format\" extension',\n        \"Suggested in JSON Schema repository's issues by maintainer.\",\n    ),\n    (\n        'Json',\n        'string',\n        {'format': 'json-string'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n    (\n        'IPv4Address',\n        'string',\n        {'format': 'ipv4'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'IPv6Address',\n        'string',\n        {'format': 'ipv6'},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'IPvAnyAddress',\n        'string',\n        {'format': 'ipvanyaddress'},\n        'Pydantic standard \"format\" extension',\n        'IPv4 or IPv6 address as used in `ipaddress` module',\n    ),\n    (\n        'IPv4Interface',\n        'string',\n        {'format': 'ipv4interface'},\n        'Pydantic standard \"format\" extension',\n        'IPv4 interface as used in `ipaddress` module',\n    ),\n    (\n        'IPv6Interface',\n        'string',\n        {'format': 'ipv6interface'},\n        'Pydantic standard \"format\" extension',\n        'IPv6 interface as used in `ipaddress` module',\n    ),\n    (\n        'IPvAnyInterface',\n        'string',\n        {'format': 'ipvanyinterface'},\n        'Pydantic standard \"format\" extension',\n        'IPv4 or IPv6 interface as used in `ipaddress` module',\n    ),\n    (\n        'IPv4Network',\n        'string',\n        {'format': 'ipv4network'},\n        'Pydantic standard \"format\" extension',\n        'IPv4 network as used in `ipaddress` module',\n    ),\n    (\n        'IPv6Network',\n        'string',\n        {'format': 'ipv6network'},\n        'Pydantic standard \"format\" extension',\n        'IPv6 network as used in `ipaddress` module',\n    ),\n    (\n        'IPvAnyNetwork',\n        'string',\n        {'format': 'ipvanynetwork'},\n        'Pydantic standard \"format\" extension',\n        'IPv4 or IPv6 network as used in `ipaddress` module',\n    ),\n    (\n        'StrictBool',\n        'boolean',\n        '',\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'StrictStr',\n        'string',\n        '',\n        'JSON Schema Core',\n        '',\n    ),\n    (\n        'ConstrainedStr',\n        'string',\n        '',\n        'JSON Schema Core',\n        (\n            'If the type has values declared for the constraints, they are included as validations. '\n            'See the mapping for `constr` below.'\n        ),\n    ),\n    (\n        \"constr(regex='^text$', min_length=2, max_length=10)\",\n        'string',\n        {'pattern': '^text$', 'minLength': 2, 'maxLength': 10},\n        'JSON Schema Validation',\n        'Any argument not passed to the function (not defined) will not be included in the schema.',\n    ),\n    (\n        'ConstrainedInt',\n        'integer',\n        '',\n        'JSON Schema Core',\n        (\n            'If the type has values declared for the constraints, they are included as validations. '\n            'See the mapping for `conint` below.'\n        ),\n    ),\n    (\n        'conint(gt=1, ge=2, lt=6, le=5, multiple_of=2)',\n        'integer',\n        {'maximum': 5, 'exclusiveMaximum': 6, 'minimum': 2, 'exclusiveMinimum': 1, 'multipleOf': 2},\n        '',\n        'Any argument not passed to the function (not defined) will not be included in the schema.',\n    ),\n    (\n        'PositiveInt',\n        'integer',\n        {'exclusiveMinimum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'NegativeInt',\n        'integer',\n        {'exclusiveMaximum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'NonNegativeInt',\n        'integer',\n        {'minimum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'NonPositiveInt',\n        'integer',\n        {'maximum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'ConstrainedFloat',\n        'number',\n        '',\n        'JSON Schema Core',\n        (\n            'If the type has values declared for the constraints, they are included as validations. '\n            'See the mapping for `confloat` below.'\n        ),\n    ),\n    (\n        'confloat(gt=1, ge=2, lt=6, le=5, multiple_of=2)',\n        'number',\n        {'maximum': 5, 'exclusiveMaximum': 6, 'minimum': 2, 'exclusiveMinimum': 1, 'multipleOf': 2},\n        'JSON Schema Validation',\n        'Any argument not passed to the function (not defined) will not be included in the schema.',\n    ),\n    (\n        'PositiveFloat',\n        'number',\n        {'exclusiveMinimum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'NegativeFloat',\n        'number',\n        {'exclusiveMaximum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'NonNegativeFloat',\n        'number',\n        {'minimum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'NonPositiveFloat',\n        'number',\n        {'maximum': 0},\n        'JSON Schema Validation',\n        '',\n    ),\n    (\n        'ConstrainedDecimal',\n        'number',\n        '',\n        'JSON Schema Core',\n        (\n            'If the type has values declared for the constraints, they are included as validations. '\n            'See the mapping for `condecimal` below.'\n        ),\n    ),\n    (\n        'condecimal(gt=1, ge=2, lt=6, le=5, multiple_of=2)',\n        'number',\n        {'maximum': 5, 'exclusiveMaximum': 6, 'minimum': 2, 'exclusiveMinimum': 1, 'multipleOf': 2},\n        'JSON Schema Validation',\n        'Any argument not passed to the function (not defined) will not be included in the schema.',\n    ),\n    (\n        'BaseModel',\n        'object',\n        '',\n        'JSON Schema Core',\n        'All the properties defined will be defined with standard JSON Schema, including submodels.',\n    ),\n    (\n        'Color',\n        'string',\n        {'format': 'color'},\n        'Pydantic standard \"format\" extension',\n        '',\n    ),\n]\n\nheadings = [\n    'Python type',\n    'JSON Schema Type',\n    'Additional JSON Schema',\n    'Defined in',\n]\n\n\ndef md2html(s: str) -&gt; str:\n    return re.sub(r'`(.+?)`', r'&lt;code&gt;\\1&lt;/code&gt;', s)\n\n\ndef build_schema_mappings() -&gt; None:\n    rows = []\n\n    for py_type, json_type, additional, defined_in, notes in table:\n        if additional and not isinstance(additional, str):\n            additional = json.dumps(additional)\n        cols = [\n            f'&lt;code&gt;{py_type}&lt;/code&gt;',\n            f'&lt;code&gt;{json_type}&lt;/code&gt;',\n            f'&lt;code&gt;{additional}&lt;/code&gt;' if additional else '',\n            md2html(defined_in)\n        ]\n        rows.append('\\n'.join(f'  &lt;td&gt;\\n    {c}\\n  &lt;/td&gt;' for c in cols))\n        if notes:\n            rows.append(\n                f'  &lt;td colspan=4 style=\"border-top: none; padding-top: 0\"&gt;\\n'\n                f'    &lt;em&gt;{md2html(notes)}&lt;/em&gt;\\n'\n                f'  &lt;/td&gt;'\n            )\n\n    heading = '\\n'.join(f'  &lt;th&gt;{h}&lt;/th&gt;' for h in headings)\n    body = '\\n&lt;/tr&gt;\\n&lt;tr&gt;\\n'.join(rows)\n    text = f\"\"\"\\\n&lt;!--\n  Generated from docs/build/schema_mapping.py, DO NOT EDIT THIS FILE DIRECTLY.\n  Instead edit docs/build/schema_mapping.py and run `make docs`.\n--&gt;\n\n&lt;table style=\"width:100%\"&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n{heading}\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n{body}\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n\"\"\"\n    (Path(\"\").parent / '..' / '.tmp_schema_mappings.html').write_text(text)\n\n\nif __name__ == '__main__':\n    build_schema_mappings()\n\n\nimport pandas as pd\nheadings_ = headings + ['Notes']\npd.DataFrame(table, columns=headings_).style\n\n\n\n\n\n\n \nPython type\nJSON Schema Type\nAdditional JSON Schema\nDefined in\nNotes\n\n\n\n\n0\nNone\nnull\n\nJSON Schema Core\nSame for `type(None)` or `Literal[None]`\n\n\n1\nbool\nboolean\n\nJSON Schema Core\n\n\n\n2\nstr\nstring\n\nJSON Schema Core\n\n\n\n3\nfloat\nnumber\n\nJSON Schema Core\n\n\n\n4\nint\ninteger\n\nJSON Schema Validation\n\n\n\n5\ndict\nobject\n\nJSON Schema Core\n\n\n\n6\nlist\narray\n{'items': {}}\nJSON Schema Core\n\n\n\n7\ntuple\narray\n{'items': {}}\nJSON Schema Core\n\n\n\n8\nset\narray\n{'items': {}, 'uniqueItems': True}\nJSON Schema Validation\n\n\n\n9\nfrozenset\narray\n{'items': {}, 'uniqueItems': True}\nJSON Schema Validation\n\n\n\n10\nList[str]\narray\n{'items': {'type': 'string'}}\nJSON Schema Validation\nAnd equivalently for any other sub type, e.g. `List[int]`.\n\n\n11\nTuple[str, ...]\narray\n{'items': {'type': 'string'}}\nJSON Schema Validation\nAnd equivalently for any other sub type, e.g. `Tuple[int, ...]`.\n\n\n12\nTuple[str, int]\narray\n{'items': [{'type': 'string'}, {'type': 'integer'}], 'minItems': 2, 'maxItems': 2}\nJSON Schema Validation\nAnd equivalently for any other set of subtypes. Note: If using schemas for OpenAPI, you shouldn't use this declaration, as it would not be valid in OpenAPI (although it is valid in JSON Schema).\n\n\n13\nDict[str, int]\nobject\n{'additionalProperties': {'type': 'integer'}}\nJSON Schema Validation\nAnd equivalently for any other subfields for dicts. Have in mind that although you can use other types as keys for dicts with Pydantic, only strings are valid keys for JSON, and so, only str is valid as JSON Schema key types.\n\n\n14\nUnion[str, int]\nanyOf\n{'anyOf': [{'type': 'string'}, {'type': 'integer'}]}\nJSON Schema Validation\nAnd equivalently for any other subfields for unions.\n\n\n15\nEnum\nenum\n{\"enum\": [...]}\nJSON Schema Validation\nAll the literal values in the enum are included in the definition.\n\n\n16\nSecretStr\nstring\n{'writeOnly': True}\nJSON Schema Validation\n\n\n\n17\nSecretBytes\nstring\n{'writeOnly': True}\nJSON Schema Validation\n\n\n\n18\nEmailStr\nstring\n{'format': 'email'}\nJSON Schema Validation\n\n\n\n19\nNameEmail\nstring\n{'format': 'name-email'}\nPydantic standard \"format\" extension\n\n\n\n20\nAnyUrl\nstring\n{'format': 'uri'}\nJSON Schema Validation\n\n\n\n21\nPattern\nstring\n{'format': 'regex'}\nJSON Schema Validation\n\n\n\n22\nbytes\nstring\n{'format': 'binary'}\nOpenAPI\n\n\n\n23\nDecimal\nnumber\n\nJSON Schema Core\n\n\n\n24\nUUID1\nstring\n{'format': 'uuid1'}\nPydantic standard \"format\" extension\n\n\n\n25\nUUID3\nstring\n{'format': 'uuid3'}\nPydantic standard \"format\" extension\n\n\n\n26\nUUID4\nstring\n{'format': 'uuid4'}\nPydantic standard \"format\" extension\n\n\n\n27\nUUID5\nstring\n{'format': 'uuid5'}\nPydantic standard \"format\" extension\n\n\n\n28\nUUID\nstring\n{'format': 'uuid'}\nPydantic standard \"format\" extension\nSuggested in OpenAPI.\n\n\n29\nFilePath\nstring\n{'format': 'file-path'}\nPydantic standard \"format\" extension\n\n\n\n30\nDirectoryPath\nstring\n{'format': 'directory-path'}\nPydantic standard \"format\" extension\n\n\n\n31\nPath\nstring\n{'format': 'path'}\nPydantic standard \"format\" extension\n\n\n\n32\ndatetime\nstring\n{'format': 'date-time'}\nJSON Schema Validation\n\n\n\n33\ndate\nstring\n{'format': 'date'}\nJSON Schema Validation\n\n\n\n34\ntime\nstring\n{'format': 'time'}\nJSON Schema Validation\n\n\n\n35\ntimedelta\nnumber\n{'format': 'time-delta'}\nDifference in seconds (a `float`), with Pydantic standard \"format\" extension\nSuggested in JSON Schema repository's issues by maintainer.\n\n\n36\nJson\nstring\n{'format': 'json-string'}\nPydantic standard \"format\" extension\n\n\n\n37\nIPv4Address\nstring\n{'format': 'ipv4'}\nJSON Schema Validation\n\n\n\n38\nIPv6Address\nstring\n{'format': 'ipv6'}\nJSON Schema Validation\n\n\n\n39\nIPvAnyAddress\nstring\n{'format': 'ipvanyaddress'}\nPydantic standard \"format\" extension\nIPv4 or IPv6 address as used in `ipaddress` module\n\n\n40\nIPv4Interface\nstring\n{'format': 'ipv4interface'}\nPydantic standard \"format\" extension\nIPv4 interface as used in `ipaddress` module\n\n\n41\nIPv6Interface\nstring\n{'format': 'ipv6interface'}\nPydantic standard \"format\" extension\nIPv6 interface as used in `ipaddress` module\n\n\n42\nIPvAnyInterface\nstring\n{'format': 'ipvanyinterface'}\nPydantic standard \"format\" extension\nIPv4 or IPv6 interface as used in `ipaddress` module\n\n\n43\nIPv4Network\nstring\n{'format': 'ipv4network'}\nPydantic standard \"format\" extension\nIPv4 network as used in `ipaddress` module\n\n\n44\nIPv6Network\nstring\n{'format': 'ipv6network'}\nPydantic standard \"format\" extension\nIPv6 network as used in `ipaddress` module\n\n\n45\nIPvAnyNetwork\nstring\n{'format': 'ipvanynetwork'}\nPydantic standard \"format\" extension\nIPv4 or IPv6 network as used in `ipaddress` module\n\n\n46\nStrictBool\nboolean\n\nJSON Schema Core\n\n\n\n47\nStrictStr\nstring\n\nJSON Schema Core\n\n\n\n48\nConstrainedStr\nstring\n\nJSON Schema Core\nIf the type has values declared for the constraints, they are included as validations. See the mapping for `constr` below.\n\n\n49\nconstr(regex='^text$', min_length=2, max_length=10)\nstring\n{'pattern': '^text$', 'minLength': 2, 'maxLength': 10}\nJSON Schema Validation\nAny argument not passed to the function (not defined) will not be included in the schema.\n\n\n50\nConstrainedInt\ninteger\n\nJSON Schema Core\nIf the type has values declared for the constraints, they are included as validations. See the mapping for `conint` below.\n\n\n51\nconint(gt=1, ge=2, lt=6, le=5, multiple_of=2)\ninteger\n{'maximum': 5, 'exclusiveMaximum': 6, 'minimum': 2, 'exclusiveMinimum': 1, 'multipleOf': 2}\n\nAny argument not passed to the function (not defined) will not be included in the schema.\n\n\n52\nPositiveInt\ninteger\n{'exclusiveMinimum': 0}\nJSON Schema Validation\n\n\n\n53\nNegativeInt\ninteger\n{'exclusiveMaximum': 0}\nJSON Schema Validation\n\n\n\n54\nNonNegativeInt\ninteger\n{'minimum': 0}\nJSON Schema Validation\n\n\n\n55\nNonPositiveInt\ninteger\n{'maximum': 0}\nJSON Schema Validation\n\n\n\n56\nConstrainedFloat\nnumber\n\nJSON Schema Core\nIf the type has values declared for the constraints, they are included as validations. See the mapping for `confloat` below.\n\n\n57\nconfloat(gt=1, ge=2, lt=6, le=5, multiple_of=2)\nnumber\n{'maximum': 5, 'exclusiveMaximum': 6, 'minimum': 2, 'exclusiveMinimum': 1, 'multipleOf': 2}\nJSON Schema Validation\nAny argument not passed to the function (not defined) will not be included in the schema.\n\n\n58\nPositiveFloat\nnumber\n{'exclusiveMinimum': 0}\nJSON Schema Validation\n\n\n\n59\nNegativeFloat\nnumber\n{'exclusiveMaximum': 0}\nJSON Schema Validation\n\n\n\n60\nNonNegativeFloat\nnumber\n{'minimum': 0}\nJSON Schema Validation\n\n\n\n61\nNonPositiveFloat\nnumber\n{'maximum': 0}\nJSON Schema Validation\n\n\n\n62\nConstrainedDecimal\nnumber\n\nJSON Schema Core\nIf the type has values declared for the constraints, they are included as validations. See the mapping for `condecimal` below.\n\n\n63\ncondecimal(gt=1, ge=2, lt=6, le=5, multiple_of=2)\nnumber\n{'maximum': 5, 'exclusiveMaximum': 6, 'minimum': 2, 'exclusiveMinimum': 1, 'multipleOf': 2}\nJSON Schema Validation\nAny argument not passed to the function (not defined) will not be included in the schema.\n\n\n64\nBaseModel\nobject\n\nJSON Schema Core\nAll the properties defined will be defined with standard JSON Schema, including submodels.\n\n\n65\nColor\nstring\n{'format': 'color'}\nPydantic standard \"format\" extension"
  },
  {
    "objectID": "issue-178.html",
    "href": "issue-178.html",
    "title": "ipyautoui",
    "section": "",
    "text": "from pydantic import BaseModel, Field, conint, model_validator, ValidationError\nfrom ipyautoui import AutoUi\n\nclass ApertureSettings(BaseModel):\n    radius : conint(ge=1) = Field(default=1)\n    inner_annulus : conint(ge=1) = Field(default=2)\n    outer_annulus : conint(ge=1) = Field(default=3)\n\n    class Config:\n        validate_assignment = True\n        validate_default = True\n\n    @model_validator(mode=\"after\")\n    def check_annuli(cls, values):\n        if values.inner_annulus &gt;= values.outer_annulus:\n            raise ValueError('inner_annulus must be smaller than outer_annulus')\n        if values.radius &gt;= values.inner_annulus:\n            raise ValueError('radius must be smaller than inner_annulus')\n        return values\n\n\nui = AutoUi(ApertureSettings)\n\ncounter = 0\ndef my_observer(change):\n    global counter\n    counter += 1\n    print(f\"My observer call {counter}\")\n    print(ui.value)\n    try: \n        ApertureSettings(**ui.value)\n    except ValidationError:\n        print(\"    Bad state\")\n    else: \n        print(\"    Good state\")\n\nui.observe(my_observer, names=\"_value\")\n\n\nui\n\n\n\n\n\nui.value = dict(radius=2, inner_annulus=7, outer_annulus=8)\n\nMy observer call 1\n{'radius': 2, 'inner_annulus': 7, 'outer_annulus': 8}\n    Good state"
  },
  {
    "objectID": "buttonbar_extended.html",
    "href": "buttonbar_extended.html",
    "title": "ipyautoui",
    "section": "",
    "text": "import ipywidgets as w\nimport traitlets as tr\nfrom ipyautoui.constants import IMAGE_BUTTON_KWARGS\nfrom ipyautoui.custom.buttonbars import CrudButtonBar, CrudOptions, CrudView\n\nfor maplocal to load openpath and runcmd callable, maplocal_example.py must exist with functions `openpath` and `runcmd`\n\n\n\nEXTENDED_BUTTONBAR_CONFIG = CrudView(\n    images=CrudOptions(\n        tooltip=\"Add image\",\n        tooltip_clicked=\"Go back to table\",\n        button_style=\"info\",\n        message=\"📷 &lt;i&gt;Adding image&lt;/i&gt;\",\n    ),\n    add=CrudOptions(\n        tooltip=\"Add item\",\n        tooltip_clicked=\"Go back to table\",\n        button_style=\"success\",\n        message=\"➕ &lt;i&gt;Adding data&lt;/i&gt;\",\n    ),\n    edit=CrudOptions(\n        tooltip=\"Edit item\",\n        tooltip_clicked=\"Go back to table\",\n        button_style=\"warning\",\n        message=\"✏️ &lt;i&gt;Editing data&lt;/i&gt;\",\n    ),\n    copy=CrudOptions(\n        tooltip=\"Copy item\",\n        tooltip_clicked=\"Go back to table\",\n        button_style=\"primary\",\n        message=\"📝 &lt;i&gt;Copying data&lt;/i&gt;\",\n    ),\n    delete=CrudOptions(\n        tooltip=\"Delete item\",\n        tooltip_clicked=\"Go back to table\",\n        button_style=\"danger\",\n        message=\"🗑️ &lt;i&gt;Deleting data&lt;/i&gt;\",\n    ),\n)\n\n\nclass CrudButtonBarExtended(CrudButtonBar):\n    fn_images = tr.Callable(default_value=lambda: print(\"add image\"))\n    \n    def __init__(self, **kwargs):\n        self.images = w.ToggleButton(**IMAGE_BUTTON_KWARGS)\n        self.images.observe(self._images, \"value\")\n        super().__init__(**kwargs | {\"crud_view\": EXTENDED_BUTTONBAR_CONFIG})\n        self.children = [\n            self.images,\n            self.add,\n            self.edit,\n            self.copy,\n            self.delete,\n            self.reload,\n            self.message,\n        ]\n\n    def _images(self, onchange):\n        self._onclick(\"images\")\n\n\nif __name__ == \"__main__\":\n    display(CrudButtonBarExtended())"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "ipyautoui",
    "section": "Documentation",
    "text": "Documentation\nhttps://maxfordham.github.io/ipyautoui/"
  },
  {
    "objectID": "index.html#try-it-online",
    "href": "index.html#try-it-online",
    "title": "ipyautoui",
    "section": "Try it online!",
    "text": "Try it online!\nlaunch ."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "ipyautoui",
    "section": "Installation",
    "text": "Installation\npip install ipyautoui\nmamba install ipyautoui -c conda-forge  # mamba ... TODO: add to conda-forge.\nconda install ipyautoui -c conda-forge  # or conda ... TODO: add to conda-forge."
  },
  {
    "objectID": "index.html#intro",
    "href": "index.html#intro",
    "title": "ipyautoui",
    "section": "Intro",
    "text": "Intro\nA high-level wrapper library that sits on top of ipywidgets (and other ipy- widget libraries), pydantic and Jupyter rich display system to template and automate the creation of widget forms / user-interfaces. The core user-facing classes in this library are AutoUi, AutoVjsf and AutoDisplay:\nfrom ipyautoui import AutoUi, AutoVjsf, AutoDisplay, demo\n\ndemo()\n ipyautoui aims to give you as much as possible out-the-box, whilst also supporting a simple workflow to extend and customise the interface to specific user requirements."
  },
  {
    "objectID": "index.html#summary-of-main-features",
    "href": "index.html#summary-of-main-features",
    "title": "ipyautoui",
    "section": "Summary of main features",
    "text": "Summary of main features\n\nAutoUi\nfrom pydantic import BaseModel, Field\nfrom ipyautoui import AutoUi\n\nclass LineGraph(BaseModel):\n    \"\"\"parameters to define a simple `y=m*x + c` line graph\"\"\"\n    title: str = Field(default='line equation', description='add chart title')\n    m: float = Field(default=2, description='gradient')\n    c: float = Field(default=5, ge=0, le=10, description='intercept')\n    x_range: tuple[int, int] = Field(\n        default=(0,5), ge=0, le=50, description='x-range for chart')\n    y_range: tuple[int, int] = Field(\n        default=(0,5), ge=0, le=50, description='y-range for chart')\n\nui = AutoUi(schema=LineGraph)\nui\n\n\n\nautoui-linegraph\n\n\nui.value  # there is a `value` trait that is always kept in-sync with the widget input form\n# {'title': 'line equation',\n#  'm': 2,\n#  'c': 5,\n#  'x_range': (0, 5),\n#  'y_range': (0, 5)}\n\n#  methods / stored values\nui.file(path) #  file data to .json file\nui.value #  input form value dict\nui.model #  pydantic model (if given as input, AutoUi can be called from a jsonschema only also)\nui.schema #  jsonschema\nAutoUi.create_autoui_renderer #  creates a json-serializable pointer\nAutoUi.parse_file #  init ui with data from .json file\n\nAutoUi uses pydantic to define the schema of User Input form, and then infers the widget to use based on type and user-directives\nipyautoui.custom. provides useful widgets (e.g. iterable) that aren’t included within the core ipywidgets library\nipyautoui defines a best practice for creating and integrating custom widgets, and as default includes some widgets from other popular widget libraries (e.g. ipydatagrid, ipyfilechooser).\nipyautoui handles observing the values, and maintains a stateful and validated .value parameter for the whole user input form.\nAutoUi also allows the user to specify the usage of ipyvuetify and\n\nnote. this is the recommended approach for simple and generic input forms. Where custom UI objects are required these can be built using the ipyautoui core library.\n\n\n\n\nAutoVjsf\nAutoVjsf works in exactly the same way as AutoUi , but instead of using ipywidgets to render the JSON schema it uses ipyvuetify and vuetify-jsonschema-form.\n\n\nShould I use AutoUi or AutoVjsf?\n\nAutoVjsf\nThe excellent documentation for vuetify-jsonschema-form can be used to create your schema. Anything possible in vjsf is therefore possible using AutoVjsf. This has a much more complete coverage of the json-schema specification, as well as the added benefit of out-the-box support of mobile applications. It falls down if you want to specify custom renderer objects.\nwhen you're using pydantic to make the schema, \"-\" cannot be used field names, \nbut vuetify-jsonschema-form requires them (e.g. \"x-display\"); \nuse \"x_display\" instead and AutoVjsf does the conversion).\n\n\n\nAutoUi\nThe main benefit of AutoUi (and main the reason for continuing to develop it), is that it makes it simple to create custom renderers for specific parts of the json-schema, facilitating the bespoke the requirements of a custom project. See custom-renderers.\n\n\n\nAutoDisplay\n\nAutoDisplay uses Jupyter’s rich display system and large ecosystem of 3rd party packages to create a simple and unified display wrapper to various filetypes.\nThe renderer for a given file is inferred from the file extension.\n\nTODO: where the datasource is not a file, the extension is a mapping code that maps a renderer to the datastructure of the data.\n\nCustom renderer’s can be passed to AutoDisplay allowing it to display user-defined filetypes (or compound extension filetypes)\n\n\n\nmaplocal\nipyautoui inherits the openpath command from maplocal when it is in use. Refer to maplocal for how to use. maplocal is not a requirement for ipyautoui, but if it is installed the openfile and runcmd functions will be taken from their."
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "ipyautoui",
    "section": "How it works",
    "text": "How it works\n\nMake a pydantic model (or json schema) that defines the UI\nPass the model to AutoUi or AutoVjsf to generate an user-interface\nSave the UI fields to file\nAssign a compound-json filetype to the schema and generate AutoDisplay rendererer\nUse AutoDisplay to display the json file using the AutoUi interface"
  },
  {
    "objectID": "index.html#dependencies",
    "href": "index.html#dependencies",
    "title": "ipyautoui",
    "section": "Dependencies",
    "text": "Dependencies\nThis package intends to be high-level, and unifies many other ipy- libraries under a simple and familiar API.\n\npydantic\nipywidgets\nipydatagrid\nipyfilechooser\nipyvuetify\nvuetify-jsonschema-form\nPlotly (for viewing .plotly.json files. note. this needs to be added by the user)\nmaplocal (for mapping rootdir between remote server and user machine)\n\nIt is also obviously wholly dependent on the excellent json-schema specification:\n\njson-schema"
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "ipyautoui",
    "section": "Contributing",
    "text": "Contributing\nipyautoui uses pixi for package management and development. Once installed:\n$ git clone https://github.com/maxfordham/ipyautoui\n$ cd ipyautoui\n\n# assuming that you have `pixi` installed:\n$ pixi run tests\n\n# view other pixi commands\n$ pixi run list"
  },
  {
    "objectID": "index.html#packaging",
    "href": "index.html#packaging",
    "title": "ipyautoui",
    "section": "Packaging",
    "text": "Packaging\n#  NOTE: restricted to core-maintainers only\npixi run build\nhatch publish -u __token__ -a &lt;your-pypi-token&gt;  # publishes to pypi"
  },
  {
    "objectID": "index.html#contributions",
    "href": "index.html#contributions",
    "title": "ipyautoui",
    "section": "Contributions",
    "text": "Contributions\nAutoVjsf is a very thin wrapper where ipyvuetify and vuetify-jsonschema-form are doing all the work. Many thanks to @mariobuikhuizen for providing me with the boiler-plate code. Contributions welcome.\nNote: this is a 3rd party that is developed independently of the pydantic.dev company; other than relying heavily on their excellent package (pydantic), it is not affiliated with pydantic.dev in any way."
  },
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "Demo",
    "section": "",
    "text": "Try on Binder\n\n\n\nThese docs requires a python kernel to run. Try on Binder \n\n\n\n\nfrom ipyautoui import demo\ndemo()"
  },
  {
    "objectID": "validation.html",
    "href": "validation.html",
    "title": "Validation - NOTE: NOT YET IMPLEMENTED",
    "section": "",
    "text": "%run ../src/ipyautoui/__init__.py\n\n\nprint(\" not yet implemented\".upper())\n\n NOT YET IMPLEMENTED\n\n\n\njsonschema validation occurs on-change by default (TODO: implement!)\n\nreview https://github.com/pydantic/pydantic-core\n\nthe top-level pydantic model can also be validated on request (slows things down…?)\n\npossible to implement recursive validation with pydantic?\n\n\n\nfrom jsonschema import validate, Draft202012Validator, ErrorTree\n\n# A sample schema, like what we'd get from json.load()\nschema = {\n    \"type\" : \"object\",\n    \"properties\" : {\n        \"price\" : {\"type\" : \"number\"},\n        \"name\" : {\"type\" : \"string\"},\n    },\n}\n\n# If no exception is raised by validate(), the instance is valid.\nvalidate(instance={\"name\" : \"Eggs\", \"price\" : 34.99}, schema=schema)\n\nvalidate(\n    instance={\"name\" : \"Eggs\", \"price\" : \"Invalid\"}, schema=schema,\n)      \n\n\n---------------------------------------------------------------------------\nValidationError                           Traceback (most recent call last)\nCell In[1], line 15\n     12 # If no exception is raised by validate(), the instance is valid.\n     13 validate(instance={\"name\" : \"Eggs\", \"price\" : 34.99}, schema=schema)\n---&gt; 15 validate(\n     16     instance={\"name\" : \"Eggs\", \"price\" : \"Invalid\"}, schema=schema,\n     17 )\n\nFile ~/micromamba/envs/ipyautoui-dev/lib/python3.11/site-packages/jsonschema/validators.py:1121, in validate(instance, schema, cls, *args, **kwargs)\n   1119 error = exceptions.best_match(validator.iter_errors(instance))\n   1120 if error is not None:\n-&gt; 1121     raise error\n\nValidationError: 'Invalid' is not of type 'number'\n\nFailed validating 'type' in schema['properties']['price']:\n    {'type': 'number'}\n\nOn instance['price']:\n    'Invalid'\n\n\n\n\nschema = {\n    \"items\": {\n        \"anyOf\": [{\"type\": \"string\", \"maxLength\": 2}, {\"type\": \"integer\", \"minimum\": 5}]\n    }\n}\ninstance = [{}, 3, \"foo\"]\nv = Draft202012Validator(schema)\nerrors = sorted(v.iter_errors(instance), key=lambda e: e.path)\nerrors\n\n[&lt;ValidationError: '{} is not valid under any of the given schemas'&gt;,\n &lt;ValidationError: '3 is not valid under any of the given schemas'&gt;,\n &lt;ValidationError: \"'foo' is not valid under any of the given schemas\"&gt;]"
  },
  {
    "objectID": "editgrid.html",
    "href": "editgrid.html",
    "title": "EditGrid",
    "section": "",
    "text": "Try on Binder\n\n\n\nThese docs requires a python kernel to run. Try on Binder \n\n\n\nimport typing as ty\nfrom pydantic import BaseModel, Field, RootModel\nfrom ipyautoui import AutoUi\n\n\nclass DataFrameCols(BaseModel):\n    string: str = Field(\"string\", column_width=100)\n    integer: int = Field(1, column_width=80)\n    floater: float = Field(3.1415, column_width=70, global_decimal_places=3)\n    something_else: float = Field(324, column_width=100)\n    nullable_string: ty.Optional[str] = None\n\n\nclass TestDataFrame(BaseModel):\n    \"\"\"a description of TestDataFrame\"\"\"\n    a: str\n    df: ty.List[DataFrameCols] = Field([DataFrameCols().model_dump(mode=\"json\")], format=\"dataframe\")\n\n\nfrom ipyautoui.custom.editgrid import EditGrid\nclass TestDataFrame(RootModel):\n    \"\"\"a description of TestDataFrame\"\"\"\n\n    root: ty.List[DataFrameCols] = Field(format=\"dataframe\")\negrid = EditGrid(schema=TestDataFrame)\negrid\n\n\n\n\n\negrid.value =  [\n        {\n            \"string\": \"important string\",\n            \"integer\": 1,\n            \"floater\": 3.14,\n            \"something_else\": 324,\n        },\n        {\"string\": \"update\", \"integer\": 4, \"floater\": 3.12344, \"something_else\": 123},\n        {\"string\": \"evening\", \"integer\": 5, \"floater\": 3.14, \"something_else\": 235},\n        {\"string\": \"morning\", \"integer\": 5, \"floater\": 3.14, \"something_else\": 12},\n        {\"string\": \"number\", \"integer\": 3, \"floater\": 3.14, \"something_else\": 123},\n    ]\n\n\nfrom pydantic import RootModel\n\n# Test: EditGrid instance with multi-indexing.\nAUTO_GRID_DEFAULT_VALUE = [\n    {\n        \"string\": \"important string\",\n        \"integer\": 1,\n        \"floater\": 3.14,\n    },\n]\nAUTO_GRID_DEFAULT_VALUE = AUTO_GRID_DEFAULT_VALUE * 4\nAUTO_GRID_DEFAULT_VALUE = AUTO_GRID_DEFAULT_VALUE + [\n    {\n        \"string\": None,\n        \"integer\": None,\n        \"floater\": None,\n    },\n]\n\nclass DataFrameCols(BaseModel):\n    string: ty.Optional[str] = Field(\n        \"string\", json_schema_extra=dict(column_width=400, section=\"a\")\n    )\n    integer: ty.Optional[int] = Field(\n        1, json_schema_extra=dict(column_width=80, section=\"a\")\n    )\n    floater: ty.Optional[float] = Field(\n        None, json_schema_extra=dict(column_width=70, section=\"b\")\n    )\n\nclass TestDataFrame(RootModel):\n    \"\"\"a description of TestDataFrame\"\"\"\n\n    root: ty.List[DataFrameCols] = Field(\n        default=AUTO_GRID_DEFAULT_VALUE,\n        json_schema_extra=dict(\n            format=\"dataframe\", datagrid_index_name=(\"section\", \"title\")\n        ),\n    )\n\ntitle = \"The Wonderful Edit Grid Application\"\ndescription = \"Useful for all editing purposes whatever they may be 👍\"\neditgrid = EditGrid(\n    schema=TestDataFrame,\n    title=title,\n    description=description,\n    ui_add=None,\n    ui_edit=None,\n    warn_on_delete=True,\n    show_copy_dialogue=False,\n    close_crud_dialogue_on_action=False,\n    global_decimal_places=1,\n    column_width={\"String\": 400},\n)\neditgrid.observe(lambda c: print(\"_value changed\"), \"_value\")\ndisplay(editgrid)\n\n\n\n\n\nclass TestProperties(BaseModel):\n    string: str\n    nullable_string: ty.Optional[str] = None\n    floater: float = 1.5\n    inty: int = 1\n\n\nclass TestGridSchema(RootModel):\n    \"\"\"no default\"\"\"\n\n    root: ty.List[TestProperties] = Field(\n        [TestProperties(string=\"string\").model_dump()],\n    )\n\negrid = EditGrid(\n        schema=TestGridSchema,\n        value=[{\"string\": \"test2\",\"nullable_string\":None, \"floater\": 2.2, \"inty\": 1}],\n    )\negrid\n\n\n\n\n\nfrom ipyautoui.autoobject import AutoObjectForm\nfrom ipyautoui.demo_schemas import CoreIpywidgets\nui = AutoObjectForm.from_pydantic_model(CoreIpywidgets)\nui\n\n\n\n\n\n# Row Validation (WIP)\n\nfrom pydantic import RootModel\n\n\nclass Sub(BaseModel):\n    a: str = \"a\"\n    b: int = 1\n\n\nclass Table(RootModel):\n    root: list[Sub]\n\n\nclass NestedTable(BaseModel):\n    table: list[Sub]\n\n\n# for simple root tables it is simple to extract the pydantic model for the row\nRowSchema = Table.__pydantic_core_schema__[\"schema\"][\"items_schema\"][\"cls\"]\nprint(RowSchema)\n\n# more difficult for nested rows\nNestedRowSchema = NestedTable.__pydantic_core_schema__[\"schema\"][\"fields\"][\"table\"][\n    \"schema\"\n][\"items_schema\"][\"cls\"]\nprint(NestedRowSchema)\n\n&lt;class '__main__.Sub'&gt;\n&lt;class '__main__.Sub'&gt;"
  },
  {
    "objectID": "issue-17.html",
    "href": "issue-17.html",
    "title": "ipyautoui",
    "section": "",
    "text": "import typing as ty\nimport pandas as pd\nfrom pydantic import BaseModel, RootModel, Field\n\nimport ipyautoui.automapschema as asch\nfrom ipyautoui import AutoUi\nfrom ipyautoui.custom.autogrid import AutoGrid, GridSchema\nfrom ipyautoui.custom.editgrid import EditGrid\nfrom ipyautoui.custom.iterable import AutoArray\nfrom ipyautoui.autoobject import AutoObject\n\n\nclass TestListCol(BaseModel):\n    li_col: list[str] = [\"a\"]\n    stringy: str = \"as\"\n    num: int = 1\n\nclass Test(RootModel):\n    root: list[TestListCol] = [TestListCol(li_col=[\"a\", \"b\"], stringy=\"asdfsadf\", num=3)]\n\nAutoArray.from_jsonschema(Test.model_json_schema())  # Defaults not being added\n\n\n\n\n\nclass TestListCol(BaseModel):\n    li_col: list[str] = [\"a\"]\n    stringy: str = \"as\"\n    num: int = 1\n\nclass Test(BaseModel):\n    li_test_list: list[TestListCol] = [TestListCol(li_col=[\"a\", \"b\"], stringy=\"asdfsadf\", num=3)]\n\nAutoObject.from_jsonschema(Test.model_json_schema())  # Defaults not being added\n\n\n\n\n\nclass TestListCol(BaseModel):\n    li_col: list[str] = [\"a\"]\n    stringy: str = \"as\"\n    num: int = 1\n\nclass Test(RootModel):\n    root: list[TestListCol] = Field([TestListCol(li_col=[\"a\", \"b\"], stringy=\"asdfsadf\", num=3)], format=\"dataframe\")\n\n\nEditGrid(schema=Test)  # Currently works for dataframe format (with EditGrid). Default row is added from Test RootModel, and AutoObjectForm shows defaults from TestListCol"
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "Release Notes",
    "section": "",
    "text": "See Github RELEASES."
  }
]